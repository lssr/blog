{
  
    
        "post0": {
            "title": "2D Linear Elasticity",
            "content": "Problem Definition . We will use FEniCS to solve the elasticity differential equations. The problem involves a 2D beam as described below . . subject to the elasticity equations . $$ mathrm{ mathbf{Kinematics:}} ; ; ; ; epsilon = frac{1}{2} left( nabla u + nabla u^{T} right) ; ; mathrm{in} ; Omega$$ $$ mathrm{ mathbf{Force ;equilibrium:}} ; ; ; ; nabla mathbf{ sigma}=0 ; ; mathrm{in} ; Omega$$ $$ mathrm{ mathbf{Constitutive ;Law:}} ; ; ; ; mathbf{ sigma} = lambda mathrm{tr}( mathbf{ epsilon}) mathbb{1}+2 mu mathbf{ epsilon} ; ; mathrm{in} ; Omega$$ . with the boundary conditions . $$ u=0 ; ; mathrm{on} ; partial Omega_{ mathrm{fixed}} $$ $$ F_x=400 ; mathrm{N/mm} ; ; mathrm{on} ; partial Omega_{ mathrm{load}} $$ $$ F_y=800 ; mathrm{N/mm} ; ; mathrm{on} ; partial Omega_{ mathrm{load}} $$ . where $u$ is the unknown displacement in the domain $ Omega$, $ epsilon$ is the strain, $ sigma$ is the stress, and $ lambda$ and $ mu$ are the material Lamé parameters that can be obtained from the Young&#39;s modulus $E$ and Poisson&#39;s ratio $ nu$. . Implementation . Import all libraries . By default mshr is not included when FEniCS is installed so you will have to install it. We found that creating a conda environment and installing mshr via conda is the easiest way. . from __future__ import print_function import region_selector_2d as rs from fenics import * from mshr import * import numpy as np import matplotlib.pyplot as plt . Then we define all the material properties, geometric dimensions, and boundary condition values. . E = 95000 # N/mm - Young&#39;s modulus nu = 0.3 # Poisson&#39;s ratio f_pos_x = 9 # mm - force position in x f_pos_y = 3 # mm - force position in y f_x = 400 # N - force magnitude in x f_y = 800 # N - force magnitude in y length = 15.5 # [mm] - overall beam length height = 3.5 # [mm] - overall beam height channel_size = 0.5 # [mm] void channel size . Geometry and mesh . In order to generate the beam geometry, we need to use mshr since the built-in meshes in FEniCS only include basic geometries. We initially create a rectangle with the overall dimensions of the beam and then subtract the void regions. . geom = Rectangle( Point(0.0, 0.0), Point(length, height)) geom -= Rectangle( Point(0.0, channel_size), Point(3*channel_size, 2*channel_size)) geom -= Rectangle( Point(0.0, height - 2*channel_size), Point(3*channel_size, height - 1*channel_size)) geom -= Rectangle( Point(1*channel_size, 3*channel_size), Point(4*channel_size, 4*channel_size)) for ch_x in np.arange(2.5, length, 1): geom -= Rectangle( Point(ch_x, channel_size), Point(ch_x + channel_size, height - channel_size)) for ch_x in np.arange(2.5, length, 2): geom -= Rectangle( Point(ch_x, 3*channel_size), Point(ch_x + 3*channel_size, 4*channel_size)) mesh = generate_mesh(geom, 30) mesh_dim = mesh.topology().dim() # Verify that the mesh is correct plt.figure(figsize=(10,2)) plot(mesh, color=&#39;b&#39;) plt.margins(0.1) plt.xlabel(&quot;x [mm]&quot;) plt.ylabel(&quot;y [mm]&quot;) plt.show() . Finite element function space and functions . Now that we have a mesh, we define the solution space V as a vector function bounded by second-degree Lagrange elements. The trial function du, test function v, and solution function u belong to the solution space V and will later be used during the variational formulation of the problem. . V = VectorFunctionSpace(mesh, &quot;Lagrange&quot;, 2) # quadradic elements du = TrialFunction(V) u = Function(V, name=&quot;Displacement&quot;) v = TestFunction(V) . Boundary conditions . We specify the location of all boundary conditions with Region Selector, a small library to select different region types in FEniCS. . Also, we create a MeshFunctionto assign arbitrary positive integers to 1 dimensional elementsto create mesh subdomains. For example, by marking bc_fixed_lower and bc_fixed_upper with a value of 1, I can now use ds(1) as a way to specify operations applicable only to the fixed boundary regions. In addition, operations using ds(2) will only apply to the loading region. . bc_fixed_height = 0.5 bc_fixed_lower = rs.GetLinearBoundary.from_points( Point(0.0, 0.0), Point(0.0, bc_fixed_height)) bc_fixed_upper = rs.GetLinearBoundary.from_points( Point(0.0, height - bc_fixed_height), Point(0.0, height)) load_region = rs.GetLinearBoundary.from_points( Point(f_pos_x - 0.4, f_pos_y), Point(f_pos_x + 0.4, f_pos_y)) boundaries = MeshFunction(&#39;size_t&#39;, mesh, mesh.topology().dim()-1) boundaries.set_all(0) bc_fixed_lower.mark(boundaries, 1) bc_fixed_upper.mark(boundaries, 1) load_region.mark(boundaries, 2) ds = Measure(&#39;ds&#39;, domain=mesh, subdomain_data=boundaries) bc_1 = DirichletBC(V, Constant((0.0, 0.0)), bc_fixed_lower) bc_2 = DirichletBC(V, Constant((0.0, 0.0)), bc_fixed_upper) bc = [bc_1, bc_2] load = Constant((f_x, f_y)) . Material model . The material model is a simple linear elastic isotropic model. The linear_material_model class takes as arguments the elastic modulus $E$ and Poisson&#39;s ratio $ nu$ since both of them are more popular in material datasheets. . class linear_material_model(): def __init__(self, E, nu): self.E = E self.nu = nu self.mesh_dim = mesh.topology().dim() def get_lame_constants(self): mu = self.E / (2.0 * (1.0 + self.nu)) lmbda = self.E*self.nu / ((1.0 + self.nu) * (1.0-2.0*self.nu)) return lmbda, mu def eps(self, u): return sym(grad(u)) def sigma(self, u): lmbda, mu = self.get_lame_constants() return lmbda*tr(self.eps(u))*Identity(self.mesh_dim) + 2.0*mu*self.eps(u) mm = linear_material_model(E, nu) . Variational problem and solution . The variational formulation in mechanics is better explained in this FEniCS tutorial. In essence, the elasticity differential equations reduce to . $$ a(du,v) = L(v) $$ where $$ a(du,v) = int_{ Omega} sigma(du): epsilon(v) mathrm{d}x $$ $$ L(v) = int_{ Omega}f cdot v mathrm{d}x + int_{ partial Omega}T cdot v mathrm{d}s $$ with $du$ as the trial function, $v$ as the test function, $f$ as the body forces, and $T$ as the traction forces. . In the elastic regime, this formulation can be viewed as conservation of energy. The internal work, $a(du,v)$, must be equal to the external work $L(v)$. . a = inner(mm.sigma(du), mm.eps(v))*dx L = dot(load,v)*ds(2) # no body forces solve(a == L, u, bc) . Results . def plot_single_result(u, u_title): plot_mode = &#39;color&#39; if not u.ufl_shape else &#39;displacement&#39; p = plot(u, mode=plot_mode, cmap=&#39;coolwarm&#39;, title=u_title) plt.colorbar(p) plt.xlabel(&quot;x [mm]&quot;) plt.ylabel(&quot;y [mm]&quot;) def plot_results(values_vec, title_vec): n_values = len(values_vec) plt.figure(figsize=(10, 4*n_values)) counter = 1 for value_i, title_i in zip(values_vec, title_vec): plt.subplot(n_values, 1, counter) plot_single_result(value_i, title_i) counter += 1 plt.show() values_vec = [u, u.sub(0), u.sub(1)] title_vec = [&#39;Displacement $u$ [mm]&#39;, &#39;Displacement $u_{x}$ [mm]&#39;, &#39;Displacement $u_{y}$ [mm]&#39;] plot_results(values_vec, title_vec) . strain = mm.eps(u) values_vec = [strain[0,0], strain[1,1], strain[0,1]] title_vec = [&#39;Strain $ epsilon_{x}$&#39;, &#39;Strain $ epsilon_{y}$&#39;, &#39;Strain $ epsilon_{xy}$&#39;] plot_results(values_vec, title_vec) . stress = mm.sigma(u) # von Mises deviatoric_stress = stress - (1./3)*tr(stress)*Identity(mesh_dim) von_mises = sqrt(3./2*inner(deviatoric_stress, deviatoric_stress)) values_vec = [stress[0,0], stress[1,1], stress[0,1], von_mises] title_vec = [&#39;Stress $ sigma_{x}$ [MPa]&#39;, &#39;Stress $ sigma_{y}$ [MPa]&#39;, &#39;Stress $ sigma_{xy}$ [MPa]&#39;, &#39;Stress $ sigma_{ mathrm{von Mises}}$ [MPa]&#39;] plot_results(values_vec, title_vec) .",
            "url": "https://lssr.github.io/blog/2020/10/20/2D-linear-elasticity_2.html",
            "relUrl": "/2020/10/20/2D-linear-elasticity_2.html",
            "date": " • Oct 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "2D Linear Elasticity",
            "content": "Problem Definition . We will use FEniCS to solve the elasticity differential equations. The problem involves a 2D beam as described below . . subject to the elasticity equations . $$ mathrm{ mathbf{Kinematics:}} ; ; ; ; epsilon = frac{1}{2} left( nabla u + nabla u^{T} right) ; ; mathrm{in} ; Omega$$ $$ mathrm{ mathbf{Force ;equilibrium:}} ; ; ; ; nabla mathbf{ sigma}=0 ; ; mathrm{in} ; Omega$$ $$ mathrm{ mathbf{Constitutive ;Law:}} ; ; ; ; mathbf{ sigma} = lambda mathrm{tr}( mathbf{ epsilon}) mathbb{1}+2 mu mathbf{ epsilon} ; ; mathrm{in} ; Omega$$ . with the boundary conditions . $$ u=0 ; ; mathrm{on} ; partial Omega_{ mathrm{fixed}} $$ $$ F_x=400 ; mathrm{N/mm} ; ; mathrm{on} ; partial Omega_{ mathrm{load}} $$ $$ F_y=800 ; mathrm{N/mm} ; ; mathrm{on} ; partial Omega_{ mathrm{load}} $$ . where $u$ is the unknown displacement in the domain $ Omega$, $ epsilon$ is the strain, $ sigma$ is the stress, and $ lambda$ and $ mu$ are the material Lamé parameters that can be obtained from the Young&#39;s modulus $E$ and Poisson&#39;s ratio $ nu$. . Implementation . Import all libraries . By default mshr is not included when FEniCS is installed so you will have to install it. We found that creating a conda environment and installing mshr via conda is the easiest way. . from __future__ import print_function import region_selector_2d as rs from fenics import * from mshr import * import numpy as np import matplotlib.pyplot as plt . Then we define all the material properties, geometric dimensions, and boundary condition values. . E = 95000 # N/mm - Young&#39;s modulus nu = 0.3 # Poisson&#39;s ratio f_pos_x = 9 # mm - force position in x f_pos_y = 3 # mm - force position in y f_x = 400 # N - force magnitude in x f_y = 800 # N - force magnitude in y length = 15.5 # [mm] - overall beam length height = 3.5 # [mm] - overall beam height channel_size = 0.5 # [mm] void channel size . Geometry and mesh . In order to generate the beam geometry, we need to use mshr since the built-in meshes in FEniCS only include basic geometries. We initially create a rectangle with the overall dimensions of the beam and then subtract the void regions. . geom = Rectangle( Point(0.0, 0.0), Point(length, height)) geom -= Rectangle( Point(0.0, channel_size), Point(3*channel_size, 2*channel_size)) geom -= Rectangle( Point(0.0, height - 2*channel_size), Point(3*channel_size, height - 1*channel_size)) geom -= Rectangle( Point(1*channel_size, 3*channel_size), Point(4*channel_size, 4*channel_size)) for ch_x in np.arange(2.5, length, 1): geom -= Rectangle( Point(ch_x, channel_size), Point(ch_x + channel_size, height - channel_size)) for ch_x in np.arange(2.5, length, 2): geom -= Rectangle( Point(ch_x, 3*channel_size), Point(ch_x + 3*channel_size, 4*channel_size)) mesh = generate_mesh(geom, 30) mesh_dim = mesh.topology().dim() # Verify that the mesh is correct plt.figure(figsize=(10,2)) plot(mesh, color=&#39;b&#39;) plt.margins(0.1) plt.xlabel(&quot;x [mm]&quot;) plt.ylabel(&quot;y [mm]&quot;) plt.show() . Finite element function space and functions . Now that we have a mesh, we define the solution space V as a vector function bounded by second-degree Lagrange elements. The trial function du, test function v, and solution function u belong to the solution space V and will later be used during the variational formulation of the problem. . V = VectorFunctionSpace(mesh, &quot;Lagrange&quot;, 2) # quadradic elements du = TrialFunction(V) u = Function(V, name=&quot;Displacement&quot;) v = TestFunction(V) . Boundary conditions . We specify the location of all boundary conditions with Region Selector, a small library to select different region types in FEniCS. . Also, we create a MeshFunctionto assign arbitrary positive integers to 1 dimensional elementsto create mesh subdomains. For example, by marking bc_fixed_lower and bc_fixed_upper with a value of 1, I can now use ds(1) as a way to specify operations applicable only to the fixed boundary regions. In addition, operations using ds(2) will only apply to the loading region. . bc_fixed_height = 0.5 bc_fixed_lower = rs.GetLinearBoundary.from_points( Point(0.0, 0.0), Point(0.0, bc_fixed_height)) bc_fixed_upper = rs.GetLinearBoundary.from_points( Point(0.0, height - bc_fixed_height), Point(0.0, height)) load_region = rs.GetLinearBoundary.from_points( Point(f_pos_x - 0.4, f_pos_y), Point(f_pos_x + 0.4, f_pos_y)) boundaries = MeshFunction(&#39;size_t&#39;, mesh, mesh.topology().dim()-1) boundaries.set_all(0) bc_fixed_lower.mark(boundaries, 1) bc_fixed_upper.mark(boundaries, 1) load_region.mark(boundaries, 2) ds = Measure(&#39;ds&#39;, domain=mesh, subdomain_data=boundaries) bc_1 = DirichletBC(V, Constant((0.0, 0.0)), bc_fixed_lower) bc_2 = DirichletBC(V, Constant((0.0, 0.0)), bc_fixed_upper) bc = [bc_1, bc_2] load = Constant((f_x, f_y)) . Material model . The material model is a simple linear elastic isotropic model. The linear_material_model class takes as arguments the elastic modulus $E$ and Poisson&#39;s ratio $ nu$ since both of them are more popular in material datasheets. . class linear_material_model(): def __init__(self, E, nu): self.E = E self.nu = nu self.mesh_dim = mesh.topology().dim() def get_lame_constants(self): mu = self.E / (2.0 * (1.0 + self.nu)) lmbda = self.E*self.nu / ((1.0 + self.nu) * (1.0-2.0*self.nu)) return lmbda, mu def eps(self, u): return sym(grad(u)) def sigma(self, u): lmbda, mu = self.get_lame_constants() return lmbda*tr(self.eps(u))*Identity(self.mesh_dim) + 2.0*mu*self.eps(u) mm = linear_material_model(E, nu) . Variational problem and solution . The variational formulation in mechanics is better explained in this FEniCS tutorial. In essence, the elasticity differential equations reduce to . $$ a(du,v) = L(v) $$ where $$ a(du,v) = int_{ Omega} sigma(du): epsilon(v) mathrm{d}x $$ $$ L(v) = int_{ Omega}f cdot v mathrm{d}x + int_{ partial Omega}T cdot v mathrm{d}s $$ with $du$ as the trial function, $v$ as the test function, $f$ as the body forces, and $T$ as the traction forces. . In the elastic regime, this formulation can be viewed as conservation of energy. The internal work, $a(du,v)$, must be equal to the external work $L(v)$. . a = inner(mm.sigma(du), mm.eps(v))*dx L = dot(load,v)*ds(2) # no body forces solve(a == L, u, bc) . Results . def plot_single_result(u, u_title): plot_mode = &#39;color&#39; if not u.ufl_shape else &#39;displacement&#39; p = plot(u, mode=plot_mode, cmap=&#39;coolwarm&#39;, title=u_title) plt.colorbar(p) plt.xlabel(&quot;x [mm]&quot;) plt.ylabel(&quot;y [mm]&quot;) def plot_results(values_vec, title_vec): n_values = len(values_vec) plt.figure(figsize=(10, 4*n_values)) counter = 1 for value_i, title_i in zip(values_vec, title_vec): plt.subplot(n_values, 1, counter) plot_single_result(value_i, title_i) counter += 1 plt.show() values_vec = [u, u.sub(0), u.sub(1)] title_vec = [&#39;Displacement $u$ [mm]&#39;, &#39;Displacement $u_{x}$ [mm]&#39;, &#39;Displacement $u_{y}$ [mm]&#39;] plot_results(values_vec, title_vec) . strain = mm.eps(u) values_vec = [strain[0,0], strain[1,1], strain[0,1]] title_vec = [&#39;Strain $ epsilon_{x}$&#39;, &#39;Strain $ epsilon_{y}$&#39;, &#39;Strain $ epsilon_{xy}$&#39;] plot_results(values_vec, title_vec) . stress = mm.sigma(u) # von Mises deviatoric_stress = stress - (1./3)*tr(stress)*Identity(mesh_dim) von_mises = sqrt(3./2*inner(deviatoric_stress, deviatoric_stress)) values_vec = [stress[0,0], stress[1,1], stress[0,1], von_mises] title_vec = [&#39;Stress $ sigma_{x}$ [MPa]&#39;, &#39;Stress $ sigma_{y}$ [MPa]&#39;, &#39;Stress $ sigma_{xy}$ [MPa]&#39;, &#39;Stress $ sigma_{ mathrm{von Mises}}$ [MPa]&#39;] plot_results(values_vec, title_vec) .",
            "url": "https://lssr.github.io/blog/fenics/2020/10/20/2D-linear-elasticity.html",
            "relUrl": "/fenics/2020/10/20/2D-linear-elasticity.html",
            "date": " • Oct 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I am a Ph.D. student at the University of Maryland under the supervision of Prof. Hugh Bruck. My research focuses on distortion and residual stress prediction in 3D printed metallic parts. . Previously, I worked as a Software Engineer Intern at Quicken Loans and as a Structures Engineer at Aeroman before getting a Fulbright Scholarship to pursue graduate studies. .",
          "url": "https://lssr.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://lssr.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}